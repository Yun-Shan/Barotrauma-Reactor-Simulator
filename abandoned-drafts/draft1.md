
温控堆，通过拉满涡轮只控裂变来提高效率，优点是反应速度能逼近理论速度，缺点是更耗油：
```text
纯裂变速率控制温度达到输出功率控制，涡轮输出固定为100
(注：暂时不使用容差是因为温度受实际涡轮影响，而温度计算中没有神奇的容差，也就是说如果涡轮用99.1的话实际上温度会偏高，但是功率生成的时候是有容差的所以也许没问题？)

此时输出功率仅由温度控制：
(1式)：输出功率 = 功率最大值 * min(当前温度 / 50, 1)
在假设涡轮不变的前提下可以得到功率最大值：
(1.1式)：功率最大值 = (输出功率 * 50) / 当前温度 = (输出功率 / 信号温度) * 5000
(2式)：当前温度 = 产生热量 - 涡轮输出 = (裂变速率 * 燃料总热值) / 50 - 100
(2.2式)：信号温度 = 2 * (裂变速率 * 燃料总热值) - 100
(2.3式)：裂变速率 = (信号温度 / 2 + 5000) / 燃料总热值
(3式)：目标功率所需温度 = 50 * min(目标功率 / 功率最大值, 1)
                     = 50 * min(目标功率 / ((输出功率 / 信号温度) * 5000), 1)


要使 输出功率 = 目标功率 ，则需要 目标裂变下的当前温度 = 目标功率所需温度，联合(2式)和(3式)：
化简得(忽略min，min由游戏内组件的温度钳值实现)：
(4式)：目标裂变速率 = ((目标功率 * 信号温度) / (2 * 输出功率) + 5000) / 燃料总热值

反应堆是通过线性插值逼近目标值，我们暂且忽略目标值，假设反应堆直接向信号值线性插值，那么我们能得到：
目标裂变速率 = 裂变新实际值 = 裂变旧实际值 + (裂变信号值 - 裂变旧实际值) * deltaTime
得：
(5式)：裂变信号值 = (deltaTime * 裂变旧实际值 - 裂变旧实际值 + 目标裂变速率) / deltaTime

在没有目标值的时候，由于温控堆的温度只由裂变速率和热值控制，因此可以通过反应堆输出的温度、热值计算内部实际的裂变速率，再提供一个能一帧插值到真实需要的裂变速率的值，即可达到满效率温控。(注：由于信号的帧延迟，实际可能会有一两帧的滞后而非实时满效率)
但有了目标值，问题就来了，实际值是向目标值插值，而非信号值插值，这意味着目标值和信号值差距太大(特别是负载反向波动的情况)时实际值会相对信号值有严重滞后，这是不可接受的。

因此我们转换思路，将目标值控制在最多让当前温度每帧变化10 * deltaTime的程度，这样当负载波动时就能快速调整回来而不会有严重的滞后。

我们定义一个调节温度：
(6式)：调节温度 = 当前温度 ± 10 * deltaTime = (信号温度 / 100) ± 10 * deltaTime
因此需要得到调节温度所需的调节裂变
根据(2式)得：
调节温度 = (调节裂变 * 燃料总热值) / 50 - 100
得：
(7式)：调节裂变 = (50 * 调节温度 + 5000) / 燃料总热值
(注1：由于虽然反应堆限制裂变信号最大值为100，但是4棒温控不会有那么高的值所以没影响)
(注2：如果你曾经看过本人的旧版温控思路，需要注意在旧版中调节裂变是强制让温度以满效率变化，但目前调节裂变已经改为了限制裂变目标值的边界)

根据(5式)得：
(8式)：调节裂变信号值 = (deltaTime * 裂变旧实际值 - 裂变旧实际值 + 调节裂变) / deltaTime

因此我们可以知道：通过(5式)计算裂变值，然后使用(8式)限制(5式)的计算结果，然后输出给反应堆，即可得到最高控制效率
由于(5式)和(8式)整体结构相同，因此可以事先计算裂变再套进去计算：
根据(4式)算得目标裂变速率，根据(7式)算得调节裂变速率， 然后用(7式)限(4式)的结果边界得到 目标调节裂变速率，然后将 目标调节裂变速率放入(8式)得到信号裂变速率，然后输出给反应堆。
尝试对流程化简(本人学艺不精，化简能力一般，不保证最简)：
(4式)：目标裂变速率 = ((目标功率 * 信号温度) / (2 * 输出功率) + 5000) / 燃料总热值
(7式)：调节裂变 = (50 * 调节温度 + 5000) / 燃料总热值
               = ((50 * ((信号温度 / 100) ± 10 * deltaTime)) + 5000) / 燃料总热值
               = 上升：(5008.333 + (信号温度 / 2)) / 燃料总热值
                 或 下降：(4991.667 + (信号温度 / 2)) / 燃料总热值

整理式子：
对于上升：
    目标裂变速率 <= 调节裂变
    ((50 * 目标功率 * 当前温度) / 输出功率 + 5000) / 燃料总热值 <= (5008.333 + (信号温度 / 2)) / 燃料总热值
    (0.5 * 信号温度 * 目标功率) / 输出功率 <= (0.5 * 信号温度) + 8.333333
    目标功率 <= 输出功率 + (8.333333 * 输出功率) / (0.5 * 信号温度)
    目标功率 <= 输出功率 + 16.66667 * (输出功率 / 信号温度)
对于下降：
    目标裂变速率 >= 调节裂变
    ((50 * 目标功率 * 当前温度) / 输出功率 + 5000) / 燃料总热值 >= (4991.667 + (信号温度 / 2)) / 燃料总热值
    (0.5 * 信号温度 * 目标功率) / 输出功率 >= (0.5 * 信号温度) - 8.333333
    目标功率 >= 输出功率 - (8.333333 * 输出功率) / (0.5 * 信号温度)
    目标功率 >= 输出功率 - 16.66667 * (输出功率 / 信号温度)

整理式子：
功率变化限制 = 输出功率 - 16.66667 * (输出功率 / 信号温度)
根据 目标功率 和 当前功率 的比较结果判断是上升还是下降
如果 上升，确保 目标功率 <= 输出功率 + 功率变化限制
如果 下降，确保 目标功率 >= 输出功率 - 功率变化限制
通过上面的逻辑得到：不超调的目标功率
不超调的目标裂变 = ((不超调的目标功率 * 信号温度) / (2 * 输出功率) + 5000) / 燃料总热值
将不超调的目标裂变代入(8式)：
调节裂变信号值 = (deltaTime * 裂变旧实际值 - 裂变旧实际值 + 不超调的目标裂变) / deltaTime
             = (0.016666667 * 裂变旧实际值 - 裂变旧实际值 + 不超调的目标裂变) / 0.016666667
根据(2.3式)得：
裂变旧实际值 = (信号温度 / 2 + 5000) / 燃料总热值

联合化简得：
调节裂变信号值 = ((输出功率 * 信号温度) * (deltaTime - 1) + 10000 * deltaTime * 输出功率 + 不超调的目标功率 * 信号温度) / (2 * deltaTime * 输出功率 * 燃料总热值)
             = (-0.9833333 * (输出功率 * 信号温度) + 166.6667 * 输出功率 + 不超调的目标功率 * 信号温度) / (0.03333334 * 输出功率 * 燃料总热值)

但是又因为这游戏计算组件上限999999，直接用上面的公式会爆，所以得把输出功率和信号温度都除以100，得：
计算妥协输出功率 = 输出功率 / 100
计算妥协信号温度 = 信号温度 / 100
调节裂变信号值 = (-0.9833333 * (计算妥协输出功率 * 信号温度) + 166.6667 * 计算妥协输出功率 + 不超调的目标功率 * 计算妥协信号温度) / (3.333334 * 计算妥协输出功率 * 燃料总热值)

至此我们就得到了理论最优的控制公式，但是由于这游戏用的单精度浮点数，实际上精度损失之后可能对控制有影响，但具体有多大影响尚不清楚
```
**错误的上面的还是有超调**  
经过实际测试小幅度变化略优于LK，略逊于KB；大幅度变化略逊于LK，优于KB；平稳期存在超调导致的震荡  
**重算！！！**

超调原因应该还是没有合理控制目标值导致的

可能需要的公式：
最高每帧温度变化量 = 10 * deltaTime
最高每帧温度变化量对应的 每帧裂变变化量 = 500 * deltaTime /  燃料总热值
联合插值公式得：
满速调整的裂变目标值 - 裂变旧实际值 = 500 /  燃料总热值
需要有一个预测后续负载的模块，然后用预测的后续负载去限制目标值
