# 潜渊症 反应堆模拟器

仅用于模拟线控反应堆，不考虑玩家和AI操控的情况。
模拟代码中剔除了AI相关和玩家相关操作的变量和逻辑。
实际反应堆有一个容差设定，会使得实际可输出功率为理论公式精确值上下增加1%或3%。
实际反应堆需要持续线控信号才能成功设置涡轮速率和裂变速率，脉冲信号是无效的，这里不判断信号的有效性，默认有持续收到信号。
连接到友好的前哨站时不消耗燃料耐久，这里不考虑，固定会消耗燃料。
多反应堆时的负载和功率分配略微复杂，这里只考虑单反应堆。


一些公式/笔记：

基础信息：
```text
每秒固定60帧，如果因为服务器物品太多导致卡顿，每秒帧数会减少，但是所有计算中用到的deltaTime仍然是1/60，因此卡顿不影响以帧为单位的计算，且所有使用deltaTime进行的每帧计算可以直接转换为每秒用于进行粗略的理解(例如每帧5*deltaTime=每秒5)。
如果使用deltaTime计算需要注意deltaTime是double类型，但是其它几乎所有地方都是float，存在精度损失(但小数点9位后的损失其实可以忽略不计)

deltaTime = 0.016666667 (因为游戏内是float精度再高也没法识别了)

功率最大值 = 引擎基础功率(不可变) * 反应堆升级 * 工程师技能加成(可堆叠，连乘)
燃料消耗率 = 反应堆设定燃料消耗率(不可变) * 服务器设置的燃料消耗倍率 * 反应堆升级 * 工程师技能加成(可堆叠，连乘)

每帧燃料耐久消耗量 = 燃料消耗率 * (裂变速率 / 100)
每根燃料棒都会计算消耗，因此多根燃料棒会同步消耗，但因为多根燃料棒的裂变需求更低因此整体消耗速度差不多
燃料耐久：铀：100，钍：200，镭：150，挥发镭：400
燃料热值：铀：80，钍：100，镭：150，挥发镭：150

裂变速率、涡轮输出 => 可通过反应堆线控设置，但需要注意有信号值、目标值、实际值：
信号值可以是0-100的任意值
目标值在不考虑内置自动控制的前提下每帧最大变化量为5 * deltaTime(自动控制会多一次2 * deltaTime的变化，但是只有省油公式堆适合用自动控制)
实际值每帧以deltaTime的速度向目标值线性插值(AI说这玩意等效一阶IIR低通滤波器，不过无论如何能确定的是实际值越接近目标值他就会变化越慢)。
信号值调整目标值：每帧最大变化量 =  5 * deltaTime = 0.083333335

当前负载 => 可通过反应堆线控获取(如果包含电池稳压电路，则要减去充电负载)

当前温度：内部计算用的温度，范围0-100，反应堆输出信号的温度会乘100
信号温度 = 当前温度 * 100

温度因数 = min(当前温度 / 50, 1)
功率因数 = min((涡轮输出 ± 容差) / 100, 温度因数)
输出功率 = 功率最大值 * clamp(功率因数, 0, 1)
产生热量 = 裂变速率 * (燃料总热值 / 100) * 2 = (裂变速率 * 燃料总热值) / 50
(产生热量的公式省略反应堆温度条的按钮强制升温/降温)
当前温度 = 产生热量 - 涡轮输出
(注意当前温度的每帧最大变化量为10 * deltaTime)
当需要满足负载功率，应满足 功率因数 >= min(负载 / 功率最大值, 1)
```

***需要注意***  
截至2025.5.8，反应堆更新逻辑为：
1. 使用上一帧的温度和涡轮生成本帧的输出功率->
2. 使用上一帧的裂变和涡轮生成更新温度->
3. 更新裂变和涡轮->
4. 输出温度、功率->
5. 结束本帧的反应堆更新，下一帧重复1-5流程

因此如果通过信号输出值取计算内部值，算出的是上一帧的内部值

标准公式堆，优点是省油，缺点是反应速度不足：
```text
如果要最省油 则：
(涡轮输出 + 容差) / 100 = min(负载 / 功率最大值, 1) = 温度因数
=> (涡轮输出 + 容差) / 100 = 温度因数 = min(当前温度 / 50, 1)
设温度不超过50：
(涡轮输出 + 容差) / 100 = 当前温度 / 50
=> 当前温度 = (涡轮输出 + 容差) / 2
将上述关系式代入目标温度公式可以得到当满足以下式子时燃料消耗速度最低：
涡轮输出 + 容差 = (裂变速率 * 燃料总热值) / 75
=> 裂变速率 = (75 * (涡轮输出 + 容差)) / 燃料总热值
而涡轮输出可根据负载关系式得到：
涡轮输出 = 100 * min(负载 / 功率最大值, 1) - 容差
```
