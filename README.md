# 潜渊症 反应堆模拟器

仅用于模拟线控反应堆，不考虑玩家和AI操控的情况。
模拟代码中剔除了AI相关和玩家相关操作的变量和逻辑。
实际反应堆有一个容差设定，会使得实际可输出功率为理论公式精确值上下增加1%或3%。
实际反应堆需要持续线控信号才能成功设置涡轮速率和裂变速率，脉冲信号是无效的，这里不判断信号的有效性，默认有持续收到信号。
连接到友好的前哨站时不消耗燃料耐久，这里不考虑，固定会消耗燃料。
多反应堆时的负载和功率分配略微复杂，这里只考虑单反应堆。


一些公式/笔记：

基础信息：
```text
每秒固定60帧，如果因为服务器物品太多导致卡顿，每秒帧数会减少，但是所有计算中用到的deltaTime仍然是1/60，因此卡顿不影响以帧为单位的计算，且所有使用deltaTime进行的每帧计算可以直接转换为每秒用于进行粗略的理解(例如每帧5*deltaTime=每秒5)。
如果使用deltaTime计算需要注意deltaTime是double类型，但是其它几乎所有地方都是float，存在精度损失(但小数点9位后的损失其实可以忽略不计)

deltaTime = 0.016666667 (因为游戏内是float精度再高也没法识别了)

功率最大值 = 引擎基础功率(不可变) * 反应堆升级 * 工程师技能加成(可堆叠，连乘)
燃料消耗率 = 反应堆设定燃料消耗率(不可变) * 服务器设置的燃料消耗倍率 * 反应堆升级 * 工程师技能加成(可堆叠，连乘)

每帧燃料耐久消耗量 = 燃料消耗率 * (裂变速率 / 100)
每根燃料棒都会计算消耗，因此多根燃料棒会同步消耗，但因为多根燃料棒的裂变需求更低因此整体消耗速度差不多
燃料耐久：铀：100，钍：200，镭：150，挥发镭：400
燃料热值：铀：80，钍：100，镭：150，挥发镭：150

裂变速率、涡轮输出 => 可通过反应堆线控设置，但需要注意有信号值、目标值、实际值：
信号值可以是0-100的任意值
目标值在不考虑内置自动控制的前提下每帧最大变化量为5 * deltaTime(自动控制会多一次2 * deltaTime的变化，但是只有省油公式堆适合用自动控制)
实际值每帧以deltaTime的速度向目标值线性插值(AI说这玩意等效一阶IIR低通滤波器，不过无论如何能确定的是实际值越接近目标值他就会变化越慢)。
信号值调整目标值：每帧最大变化量 =  5 * deltaTime = 0.083333335

当前负载 => 可通过反应堆线控获取(如果包含电池稳压电路，则要减去充电负载)

当前温度：内部计算用的温度，范围0-100，反应堆输出信号的温度会乘100
信号温度 = 当前温度 * 100

温度因数 = min(当前温度 / 50, 1)
功率因数 = min((涡轮输出 ± 容差) / 100, 温度因数)
输出功率 = 功率最大值 * clamp(功率因数, 0, 1)
产生热量 = 裂变速率 * (燃料总热值 / 100) * 2 = (裂变速率 * 燃料总热值) / 50
(产生热量的公式省略反应堆温度条的按钮强制升温/降温)
当前温度 = 产生热量 - 涡轮输出
(注意当前温度的每帧最大变化量为10 * deltaTime)
当需要满足负载功率，应满足 功率因数 >= min(负载 / 功率最大值, 1)
```

***需要注意***  
截至2025.5.8，反应堆更新逻辑为：
1. 使用上一帧的温度和涡轮生成本帧的输出功率->
2. 使用上一帧的裂变和涡轮生成更新温度->
3. 更新裂变和涡轮->
4. 输出温度、功率->
5. 结束本帧的反应堆更新，下一帧重复1-5流程

因此如果通过信号输出值取计算内部值，算出的是上一帧的内部值

标准公式堆，优点是省油，缺点是反应速度不足：
```text
如果要最省油 则：
(涡轮输出 + 容差) / 100 = min(负载 / 功率最大值, 1) = 温度因数
=> (涡轮输出 + 容差) / 100 = 温度因数 = min(当前温度 / 50, 1)
设温度不超过50：
(涡轮输出 + 容差) / 100 = 当前温度 / 50
=> 当前温度 = (涡轮输出 + 容差) / 2
将上述关系式代入目标温度公式可以得到当满足以下式子时燃料消耗速度最低：
涡轮输出 + 容差 = (裂变速率 * 燃料总热值) / 75
=> 裂变速率 = (75 * (涡轮输出 + 容差)) / 燃料总热值
而涡轮输出可根据负载关系式得到：
涡轮输出 = 100 * min(负载 / 功率最大值, 1) - 容差
```

温控堆，通过拉满涡轮只控裂变来提高效率，优点是反应速度能逼近理论速度，缺点是更耗油：
```text
纯裂变速率控制温度达到输出功率控制，涡轮输出固定为100 - 0.9 = 99.1 (神奇的容差)

注意以下说明中的温度分为"温度"和"信号温度"，没有信号前缀的意味着是内部温度，有信号前缀的是内部温度*100的结果

此时输出功率仅由温度控制：
(1式)：输出功率 = 功率最大值 * min(当前温度 / 50, 1)
(1.1式)：功率最大值 = (输出功率 * 50) / 当前温度 = (输出功率 / 信号温度) * 5000
(1.2式)：当前温度 = 50 * min(输出功率 / 功率最大值, 1)
(2式)：当前温度 = 产生热量 - 涡轮输出 = (裂变速率 * 燃料总热值) / 50 - 涡轮输出
(2.1式)：信号温度 = 2 * (裂变速率 * 燃料总热值) - 100 * 涡轮输出
(2.2式)：需求产生热量 = 信号温度 + 100 * 涡轮输出
                    = 2 * (裂变速率 * 燃料总热值) - 100 * 涡轮输出 + 100 * 涡轮输出
                    = 2 * (裂变速率 * 燃料总热值)
(2.3式)：裂变速率 = (信号温度 / 2 + 50 * 涡轮输出) / 燃料总热值
                = 需求产生热量 / (2 * 燃料总热值)  
根据(1.2式)得：
(3式)：目标功率所需温度 = 50 * min(目标功率 / 功率最大值, 1)
(3.1式)：目标功率所需信号温度 = 目标功率所需温度 * 100
                          = 5000 * min(目标功率 / ((输出功率 / 信号温度) * 5000), 1)
                          = min(目标功率 / (输出功率 / 信号温度), 5000)
                          = min(目标功率 * (信号温度 / 输出功率), 5000)

每帧温度变化量为 10 * deltaTime，而信号温度要再乘100，所以：
(4式)：每帧最多可变化的信号温度 = 10 * deltaTime * 100 = 16.66666667 (如果要填进钳制就只能是16.7了);
(4.1式)：需求信号温度变化差值 = clamp(目标功率所需信号温度 - 信号温度, -16.7, 16.7);
联合(2式)得：
每帧最多可变化的温度 = (新产生热量 - 涡轮输出) - (旧产生热量 - 涡轮输出)
                      = 新产生热量 - 旧产生热量
                      = ((新裂变速率 * 燃料总热值) / 50) - ((旧裂变速率 * 燃料总热值) / 50)
                      = (新裂变速率 - 旧裂变速率) * (燃料总热值 / 50)
因此：
(4.2式)：每帧最多可变化的裂变值 = (新裂变速率 - 旧裂变速率)
                            = 每帧最多可变化的温度 / (燃料总热值 / 50)
                            = 500 * deltaTime / 燃料总热值

由于反应堆内部通过插值改变裂变值，我们可以得到：
(5式)：裂变新实际值 = 裂变旧实际值 + (裂变目标值 - 裂变旧实际值) * deltaTime
(5.1式)：裂变目标值 = (裂变旧实际值 - (deltaTime - 1) + 裂变新实际值) / deltaTime
另有：裂变目标值和涡轮目标值的每帧最大变化量为 5 * deltaTime
根据(2.3式)，当涡轮输出和燃料总热值不变时，裂变和温度成固定比例，因此可以得到：
(5.2式)：调节信号温度 = (当前信号温度 * (deltaTime - 1) + 目标信号温度) / deltaTime

联立(4.2式)和(5式)得：
每帧最多可变化的裂变值 = (新裂变速率 - 旧裂变速率) = 500 * deltaTime / 燃料总热值 = (裂变目标值 - 裂变旧实际值) * deltaTime
因此：
(5.3式)：最大裂变调节差值 = 500 / 燃料总热值


这样我们就通过反向插值的方式得到了能够直接插值插到目标温度的调节信号温度。
(注：云闪的旧版温控逻辑是将调节温度固定为正负最大值，有超调的风险，而新版则是通过插值的方式直接插到目标值，一步到位不超调)

到此为止我们实现了固定负载变化(相当于负载是个频率较低的方波)的理论最优调整。
但如果只有这么简单的变化不如干脆用省油公式堆得了，现实是温控堆必须考虑更复杂的变化。
那么问题就来了，当变化复杂时以上的调整方式是会过冲的，原因是当负载反向变化时，目标值只能以每帧5 * deltaTime的速度变化，
这就导致负载反向变化后的一小段时间目标值调整不过去，因此功率就不能立刻向负载方向变化了。

要解决这个问题，就得"预测"负载后续的变化：
这里提出一种简单的预测方式：单纯通过这一帧和上一帧负载差值乘以指定帧率
指定帧率是在指定的燃料总热值下，目标裂变和当前裂变的差值从最大值降低到0所需要的帧数，得：
(6式)：指定帧率 = 最大裂变调节差值 / 裂变目标值的最大变化量
              = (500 / 燃料总热值) / (5 * deltaTime)
              = 6000 / 燃料总热值
(7式)：预测信号温度差值 = 指定帧率 * (目标功率所需信号温度 - 上一帧的目标功率所需信号温度)
(7.1式)：预测信号温度 = 目标功率所需信号温度 + 预测信号温度差值
需要指出这样的预测方式并不一定是最优的，但是完全够用了。

下面通过预测温度对调节信号温度进行修正：
判断(7式)和(4.1式)，如果两者的结果是异号的，说明功率变化方向和负载变化方向是相反的，
因此需要限制调节信号温度的范围，这里将调节信号温度的范围以预测信号温度为边界进行限制：
即：
(8式)：调节信号温度 = if (预测信号温度差值 < 0) min(调节信号温度, 预测信号温度) else max(调节信号温度, 预测信号温度);

根据(5.2式)和(8式)，我们可以得到最终的调节温度，这样我们就可以继续计算需要输出的裂变和涡轮了

根据(2式)，我们需要先确定涡轮输出，根据是否单铀棒可以得到：
(9.1式)：涡轮消耗热量 = if (热值 == 80) 8500 else 9910;
(9.2式)：需求的产生热量 = 调节信号温度 + 涡轮消耗热量
根据(2.3式)得：
(9.3式)：输出裂变速率 = 需求产生热量 / (2 * 燃料总热值)
其中该公式中的2可以用正则组件识别当前温度，如果过热则变成一个超大的值使得最终裂变极低来进行降温
另外涡轮也需要单铀棒处理：
(9.4式)：输出涡轮速率 = if (热值 == 80) 85 else 99.1;

至此我们已经完成了所有的计算，(9.3式)和(9.4式)就是最终输出给反应堆的结果了
需要注意的是，这种算法对平稳负载会有一小段的振荡，这是因为功率计算是不精确也不稳定的
要完美调控必须要有精确值，但好在目前这个不精确的值也够用了
```
